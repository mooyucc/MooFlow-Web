# 导入导出排版修复说明

## 问题描述

用户反馈在重新导入文件时，原来文件的排版全部都没有保留下来，任务卡片位置乱掉了。同时，导入导出文件时需要同时保留时间颗粒度信息和连线属性信息，并在导入时切换到保存时的设置，确保排版与时间颗粒度、连线样式保持一致。这个问题在水平布局和垂直布局下都需要修复。

## 问题分析

经过代码分析，发现以下问题：

1. **位置信息丢失**：导入时虽然保留了任务的 `position` 信息，但在某些情况下可能没有正确应用
2. **样式字段缺失**：导入的任务可能缺少必要的样式字段，导致显示异常
3. **批量导入处理不当**：原有的逐个添加任务的方式可能导致位置信息丢失
4. **时间颗粒度信息丢失**：导入时没有保留和恢复时间颗粒度设置，导致时间轴显示不正确
5. **连线属性信息丢失**：导入时没有保留连线的样式属性（线形、箭头、颜色、线宽等），导致连线显示不正确
6. **垂直布局自动排列问题**：导入垂直布局文件时，自动排列功能会覆盖保存的位置信息，导致排版丢失
7. **文件切换自动排列问题**：在多个文件间切换时，布局变化会错误地触发自动排列功能，导致任务位置被重置
8. **关闭文件切换自动排列问题**：关闭当前文件时，切换到其他文件会触发自动排列功能，导致未关闭文件的卡片位置被重置

## 修复方案

### 1. 增强任务存储的 `addTask` 函数

在 `src/store/taskStore.js` 中修改 `addTask` 函数，确保所有任务都有完整的位置和样式信息：

```javascript
// 确保任务有完整的位置信息
const processedTask = {
  ...task,
  type,
  date: task.date || null,
  collapsed: task.collapsed || false,
  importantLevel: task.importantLevel || 'normal',
  position: task.position || { x: 100, y: 100 },
  // 确保样式字段存在
  fillColor: task.fillColor || defaultTaskStyle.fillColor,
  borderColor: task.borderColor || defaultTaskStyle.borderColor,
  // ... 其他样式字段
};
```

### 2. 新增批量导入函数

在 `src/store/taskStore.js` 中新增 `importTasks` 函数，专门用于文件导入：

```javascript
// 新增：批量导入任务（用于文件导入）
importTasks: (tasks) => {
  set((state) => {
    // 确保所有任务都有完整的信息
    const processedTasks = tasks.map(task => {
      // 自动分配 type 字段
      let type = task.type;
      if (!type) {
        if (task.parentId === null) type = 'center';
        else if (task.level === 1) type = 'main';
        else if (task.level === 2) type = 'sub';
        else if (task.level >= 3) type = 'detail';
        // ... 类型推断逻辑
      }
      
      return {
        ...task,
        type,
        position: task.position || { x: 100, y: 100 },
        // 确保所有样式字段存在
        fillColor: task.fillColor || defaultTaskStyle.fillColor,
        // ... 其他字段
      };
    });
    
    const newTasks = ensureLinksLabel(processedTasks);
    saveTasksToStorage(newTasks);
    return { tasks: newTasks };
  });
},
```

### 3. 优化导入处理逻辑

在 `src/components/CanvasFileToolbar.jsx` 中修改 `handleImport` 函数：

```javascript
// 清空当前任务并批量导入新任务
clearTasks();
importTasks(tasks);

// 同步到当前Tab，包含布局方向和时间颗粒度
setFiles(prev => {
  const updated = prev.map(f => f.id === activeFileId ? { 
    ...f, 
    tasks: tasks,
    mainDirection: mainDirection,
    timeScale: importedTimeScale // 新增：保存导入的时间颗粒度
  } : f);
  localStorage.setItem('moo_files', JSON.stringify(updated));
  return updated;
});

// 更新画布属性，包括布局方向
setCanvasProps(prev => ({
  ...prev,
  ...canvasProps,
  mainDirection: mainDirection
}));

// 更新时间颗粒度
if (setTimeScale && importedTimeScale) {
  setTimeScale(importedTimeScale);
}
```

### 4. 新增时间颗粒度支持

在 `src/components/MainCanvas.jsx` 中传递时间颗粒度参数：

```javascript
<CanvasFileToolbar 
  // ... 其他属性
  timeScale={timeScale}
  setTimeScale={setTimeScale}
/>
```

在 `src/components/CanvasFileToolbar.jsx` 中接收并处理时间颗粒度：

```javascript
const CanvasFileToolbar = ({
  // ... 其他属性
  timeScale,
  setTimeScale
}) => {
  // 导出时包含时间颗粒度
  const exportData = {
    tasks: file ? file.tasks : [],
    mainDirection: file?.mainDirection || 'horizontal',
    canvasProps: canvasProps,
    timeScale: timeScale || 'month' // 新增：时间颗粒度
  };
  
  // 导入时恢复时间颗粒度
  const importedTimeScale = importedData.timeScale || 'month';
  if (setTimeScale && importedTimeScale) {
    setTimeScale(importedTimeScale);
  }
};
```

### 6. 修复垂直布局自动排列问题

在 `src/components/CanvasFileToolbar.jsx` 中添加导入标志：

```javascript
// 更新画布属性，包括布局方向
// 添加导入标志，防止自动排列
setCanvasProps(prev => ({
  ...prev,
  ...canvasProps,
  mainDirection: mainDirection,
  _isImporting: true // 添加导入标志
}));

// 清除导入标志
setTimeout(() => {
  setCanvasProps(prev => {
    const { _isImporting, ...rest } = prev;
    return rest;
  });
}, 200);
```

在 `src/components/FormatSidebar.jsx` 中检查导入标志：

```javascript
// 监听canvasProps.mainDirection变化，自动调用autoArrangeTasks
useEffect(() => {
  // 检查是否是导入操作
  if (canvasProps._isImporting) {
    return; // 如果是导入，不执行自动排列
  }
  
  if (autoArrangeTasks && canvasProps.mainDirection) {
    setTimeout(() => {
      autoArrangeTasks();
    }, 100);
  }
}, [canvasProps.mainDirection]);
```

### 7. 修复文件切换自动排列问题

在 `src/components/CanvasFileToolbar.jsx` 中为所有文件切换操作添加标志：

```javascript
// switchFile 函数
setCanvasProps(prev => ({ 
  ...prev, 
  mainDirection: file.mainDirection ?? 'horizontal',
  _isSwitchingFile: true // 添加文件切换标志
}));

// handleNewFile 函数
setCanvasProps(prev => ({ 
  ...prev, 
  mainDirection: newFile.mainDirection,
  _isSwitchingFile: true // 添加文件切换标志
}));

// handleCloseFile 函数
setCanvasProps(prev => ({ 
  ...prev, 
  mainDirection: newFile.mainDirection,
  _isSwitchingFile: true // 添加文件切换标志
}));

// handleOpenRecent 函数
setCanvasProps(prev => ({ 
  ...prev, 
  mainDirection: fileMainDirection,
  _isSwitchingFile: true // 添加文件切换标志
}));

// 清除文件切换标志
setTimeout(() => {
  setCanvasProps(prev => {
    const { _isSwitchingFile, ...rest } = prev;
    return rest;
  });
}, 200);
```

在 `src/components/FormatSidebar.jsx` 中检查文件切换标志：

```javascript
useEffect(() => {
  // 检查是否是导入操作或文件切换操作
  if (canvasProps._isImporting || canvasProps._isSwitchingFile) {
    return; // 如果是导入或文件切换，不执行自动排列
  }
  
  if (autoArrangeTasks && canvasProps.mainDirection) {
    setTimeout(() => {
      autoArrangeTasks();
    }, 100);
  }
}, [canvasProps.mainDirection]);
```

### 8. 修复关闭文件切换自动排列问题

在 `src/components/CanvasFileToolbar.jsx` 的 `handleCloseFile` 函数中添加文件切换标志：

```javascript
// 如果关闭的是当前Tab，切换到前一个或第一个
if (activeFileId === fileId) {
  const nextIdx = idx > 0 ? idx - 1 : 0;
  const nextFile = newFiles[nextIdx];
  clearTasks();
  nextFile.tasks.forEach(t => addTask(t));
  setActiveFileId(nextFile.id);
  
  // 添加文件切换标志，防止自动排列
  setCanvasProps(prev => ({ 
    ...prev, 
    mainDirection: nextFile.mainDirection ?? 'horizontal',
    _isSwitchingFile: true // 添加文件切换标志
  }));
  
  // 清除文件切换标志
  setTimeout(() => {
    setCanvasProps(prev => {
      const { _isSwitchingFile, ...rest } = prev;
      return rest;
    });
  }, 200);
}
```

### 5. 新增连线属性支持

在 `src/store/taskStore.js` 中增强连线属性处理：

```javascript
// 辅助函数：保证所有 links 都有完整的属性字段
function ensureLinksLabel(tasks) {
  const withType = ensureTaskType(tasks);
  return withType.map(t => ({
    ...t,
    links: (t.links || []).map(l => ({
      ...l,
      label: typeof l.label === 'string' ? l.label : '',
      // 确保连线样式属性存在
      lineStyle: l.lineStyle || defaultLinkStyle.lineStyle,
      arrowStyle: l.arrowStyle || defaultLinkStyle.arrowStyle,
      lineWidth: l.lineWidth || defaultLinkStyle.lineWidth,
      color: l.color || defaultLinkStyle.color,
      // 确保锚点信息存在
      fromAnchor: l.fromAnchor || null,
      toAnchor: l.toAnchor || null
    }))
  }));
}
```

在 `importTasks` 函数中确保连线属性完整：

```javascript
// 确保连线信息完整
const processedLinks = (task.links || []).map(link => ({
  ...link,
  label: typeof link.label === 'string' ? link.label : '',
  // 确保连线样式属性存在
  lineStyle: link.lineStyle || defaultLinkStyle.lineStyle,
  arrowStyle: link.arrowStyle || defaultLinkStyle.arrowStyle,
  lineWidth: link.lineWidth || defaultLinkStyle.lineWidth,
  color: link.color || defaultLinkStyle.color,
  // 确保锚点信息存在
  fromAnchor: link.fromAnchor || null,
  toAnchor: link.toAnchor || null
}));
```

## 修复效果

### 修复前的问题
- 导入后任务位置丢失
- 样式信息不完整
- 布局方向可能不正确

### 修复后的改进
- ✅ 完整保留任务位置信息
- ✅ 确保所有样式字段存在
- ✅ 正确同步布局方向
- ✅ 支持新旧格式兼容
- ✅ 批量导入性能更好
- ✅ 完整保留时间颗粒度信息
- ✅ 导入时自动切换到保存时的时间颗粒度
- ✅ 完整保留连线属性信息（线形、箭头、颜色、线宽、锚点）
- ✅ 导入时自动恢复连线样式设置
- ✅ 支持水平布局和垂直布局的完整导入导出
- ✅ 防止导入时自动排列覆盖保存的位置信息
- ✅ 防止文件切换时自动排列覆盖保存的位置信息
- ✅ 防止关闭文件切换时自动排列覆盖保存的位置信息

## 测试验证

创建了测试脚本验证修复效果：

```javascript
// 测试数据包含完整的位置、样式信息、时间颗粒度和连线属性
const testData = {
  tasks: [
    {
      id: 1,
      title: "中心任务",
      position: { x: 100, y: 100 },
      links: [
        {
          toId: 2,
          label: '依赖关系',
          lineStyle: 'dashed',
          arrowStyle: 'triangle',
          lineWidth: 3,
          color: '#ff6b6b',
          fromAnchor: { x: 0, y: 36 },
          toAnchor: { x: 180, y: 36 }
        }
      ],
      // ... 完整样式信息
    },
    // ... 其他任务
  ],
  mainDirection: 'horizontal',
  canvasProps: { /* 画布属性 */ },
  timeScale: 'week' // 时间颗粒度
};
```

测试结果显示：
- ✅ 任务数量正确：3个
- ✅ 布局方向正确：horizontal/vertical
- ✅ 位置信息完整：所有任务位置都正确保留
- ✅ 时间颗粒度正确恢复：week
- ✅ 连线属性正确恢复：线形、箭头、颜色、线宽、锚点
- ✅ 垂直布局验证通过：主线任务垂直排列，子任务在右侧
- ✅ 文件切换验证通过：不同布局文件间切换保持各自位置
- ✅ 关闭文件切换验证通过：关闭当前文件时正确切换到其他文件
- ✅ 旧格式兼容性正确：默认样式

## 使用说明

### 导出文件
1. 在画布中设置好任务位置、布局、时间颗粒度和连线样式
2. 点击导出按钮选择JSON格式
3. 文件将包含完整的任务位置、样式信息、时间颗粒度和连线属性

### 导入文件
1. 点击导入按钮选择之前导出的文件
2. 系统会自动还原所有任务的位置、样式和连线
3. 布局方向、时间颗粒度和连线样式也会正确恢复

## 兼容性

- ✅ 支持新格式文件（包含布局信息、时间颗粒度和连线属性）
- ✅ 兼容旧格式文件（仅任务数组，默认月颗粒度和默认连线样式）
- ✅ 向后兼容，不影响现有功能

## 注意事项

1. 导入后建议使用"自动排列"功能优化卡片位置
2. 如果导入的文件格式不正确，会显示错误提示
3. 导入会覆盖当前文件的内容，请确保已保存重要数据
4. 连线样式包括：线形（实线、虚线、点线）、箭头样式（普通、三角形、菱形、无箭头）、线宽、颜色等
5. 旧格式文件导入时会使用默认连线样式（实线、普通箭头、2px线宽、灰色）
6. 垂直布局下，主线任务垂直排列（x坐标相同，y坐标递增），子任务在主线任务右侧（x坐标更大，y坐标相同）
7. 导入时会自动切换到保存时的布局方向，无需手动切换
8. 文件切换时会自动切换到对应文件的布局方向，不会触发自动排列
9. 关闭当前文件时，会正确切换到其他文件，不会触发自动排列
